---
title: "Building my CV"
---

My CV is generated by code. This means everything is in plaintext and easily manageable by version control.

## Overview

The final output I am looking for is a single document consisting of two pages. The first document is a single page text with a brief introduction, commercial experience, other relevant experience and education; followed by second document, a skill tree/graph.

| Document 1 | Document 2 |
|:-:|:-:|
| ![Preview Document 1](/img/articles/resume/preview_resume.png) | ![Preview Document 2](/img/articles/resume/preview_skills.png)  |

## Experience

This is a single page (with some great difficulty squeezing everything in) that is built in PHP by using TCPDF.

Using `TCPDF` is relatively well documented (though not the easiest to use with the enormous amount of arguments in most method calls) so I won't explain in great detail.

This is a relatively straightforward process although I use a non-standard font, so this involves converting a `ttf` using `tools/tcpdf_addfont.php`.

The main entry looks like this:

```php {hl_lines=[3,14]}
public function build()
{
    $this->addHeaderDecoration();
    $this->addHeaderContent();

    $this->addSummary();
    $this->addTechnicalSkills();

    $this->addCommercialExperience();
    $this->addOtherRelevantExperience();

    $this->addEducation();

    $this->pdf->setPDFVersion('1.4');
}
```

* The `addHeaderContent` includes some personal information, so this is read from `env`.
* I explicitly use `setPDFVersion`, so I can manipulate the document later on, the default is `1.7`.

I use a `Makefile` as a runner to build the document, it looks something like this:

```makefile
image_php = "webdevops/php:7.4"
# Reusable docker run command
docker_run = docker run 
  --rm \
  $(shell tty -s && echo "-i" || echo) \
  -v "$(shell pwd):/app" \
  -w "/app"

cv_pdf:
  ${docker_run} -t --env-file=".env" ${image_php} php src/index.php
```

Running `make cv_pdf` will build a `build/cv.pdf`.

---

This is one of the more laborious ways to generate such a document, but the main benefits of generating this way over, say, an HTML/CSS page that is converted to a PDF using a headless browser such as by [`puppeteer`](https://github.com/puppeteer/puppeteer):

* File size is usually much smaller.
* Much greater control of layout.
* Adding bookmarks.
* Customising certain meta attributes.
* Some security features and other things I haven't investigated.

![Preview Document 1](/img/articles/resume/preview.png)

Easter egg:

<center>

![Meta Document 1](/img/articles/resume/meta_cv.png)

</center>

## Skills

I have created a [roadmap.sh](https://roadmap.sh/backend) inspired skill tree/graph, it can be seen on my [homepage](https://ac93.uk).

This is generated using [`graphviz`](https://graphviz.org/) with my tree/graph markup as a [`dot`](https://graphviz.org/doc/info/lang.html) file.

My build process will generate this as a `pdf`, `svg`, and `png`.

Unfortunately `dot` doesn't have variables, so I use `skills.tmpl` as source file, and run [`envsubst`](https://linux.die.net/man/1/envsubst) to build a true `dot` file.

`skills.sh`:

```bash
#!/usr/bin/env bash
export SKILLS_FONT_NAME="Cousine"
# etc.

envsubst < skills.tmpl > skills.dot
```

---

Unfortunately I have decided to use a non-standard font here too... Obviously this is to be containerised... So I will need to install a font in a container for `graphviz` to be able to work with.

I have used a multi-stage build to accomplish this.

```Dockerfile {hl_lines=[2,9,10,11,13]}
FROM bitnami/git:latest as font
RUN git -C /tmp clone https://github.com/googlefonts/cousine.git font

FROM nshine/dot:latest
# path inside repo with trailing slash
ARG font_path=fonts/ttf/unhinted/variable_ttf/
USER 0
RUN mkdir /usr/share/fonts/newfont
COPY --from=font /tmp/font /tmp/font
RUN find /tmp/font/$font_path -name '*.ttf' \
  -exec install -v -m644 {} /usr/share/fonts/newfont \;
USER 1000
RUN fc-cache -v -f
CMD ["sh"]
```

* First container is just a lightweight container to `git clone` a font from Google fonts Github repository. 
* Then I will copy the `git` repo from the first stage into the base `dot` image used to build the assets and install the font and update font cache.

Then the image, and skills tree assets are built like this:

`Makefile`:

```makefile
# The image name of one used to build dot things
image_skills = alistaircol/resume

# Reusable docker run command
docker_run = docker run --rm \
  $(shell tty -s && echo "-i" || echo) \
  -v "$(shell pwd):/app" \
  -w "/app"

# build an image to install custom font and make pretty graphics
skills_docker:
	BUILDKIT_PROGRESS=plain docker build --tag=${image_skills} .

# make png version of skills
skills_png:
	${docker_run} -u $(shell id -u) ${image_skills} \
	  dot -Tpng -o build/skills.png skills.dot
	${docker_run} -u $(shell id -u) ${image_skills} \
	  dot -Tpng -Gbgcolor="#41403e" -o build/skills-web.png skills.dot

# make svg version of skills
skills_svg:
	${docker_run} -u $(shell id -u) ${image_skills} \
	  dot -Tsvg -o build/skills.svg skills.dot

# make pdf version of skills
skills_pdf:
	${docker_run} -u $(shell id -u) ${image_skills} \
	  dot -Tpdf -o build/skills.pdf skills.dot
```

![Preview Document 2](/img/articles/resume/preview_skills.png)

Easter egg:

<center>

![Meta Document 2](/img/articles/resume/meta_skills.png)

</center>

## Concatenation

This is a relatively simple process. I use `mnuessler/pdftk` to combine the separate documents into a single document.

```makefile
# Reusable docker run command
docker_run = docker run --rm \
  $(shell tty -s && echo "-i" || echo) \
  -v "$(shell pwd):/app" \
  -w "/app"
  
combine_documents:
  ${docker_run} -t mnuessler/pdftk \
    build/cv.pdf \
    build/skills.pdf \
    cat output build/resume.pdf
```

## Metadata

Likely no one will care, but I use `mnuessler/pdftk` to get and update the metadata of the documents with `dump_data_utf8` and `update_info_utf8` respectively.

### Get Metadata

Basically I dump the metadata of the document and delete all lines starting with `Info` and merge them with a file of the metadata `Info` attributes I want to change.

This file will be used in the next step to update a document's metadata.

```makefile
# Reusable docker run command
docker_run = docker run --rm \
  $(shell tty -s && echo "-i" || echo) \
  -v "$(shell pwd):/app" \
  -w "/app"
  
get_meta_skills_pdf:
  ${docker_run} -t mnuessler/pdftk build/skills.pdf dump_data_utf8 \
    | sed '/^Info/d' \
    | cat .pdf/skills.txt - > build/skills.meta
```

`.pdf.skills.txt`:

```text
InfoBegin
InfoKey: Creator
InfoValue: https://ac93.dev
InfoBegin
InfoKey: Producer
InfoValue: Alistair Collins - with Graphviz
InfoBegin
InfoKey: Title
InfoValue: Alistair Collins - Skills
InfoBegin
InfoKey: Subject
InfoValue: Skills
InfoBegin
InfoKey: Author
InfoValue: Alistair Collins
```

### Update Metadata

Just update the document's metadata to be that which we dumped previously in to the `build/skills.meta` file. 

You may need to move/copy the file since this update cannot be done 'in-place' (I append the `.tmp` suffix to the file after dumping the metadata).

```makefile
# Reusable docker run command
docker_run = docker run --rm \
  $(shell tty -s && echo "-i" || echo) \
  -v "$(shell pwd):/app" \
  -w "/app"
  
set_meta_skills_pdf:
  ${docker_run} mnuessler/pdftk build/skills.pdf.tmp \
    update_info_utf8 build/skills.meta \
    output build/skills.pdf
```


| Before | After |
|:-:|:-:|
| ![Skills Meta Before](/img/articles/resume/meta_skills_before.png) | ![Skilsl Meta After](/img/articles/resume/meta_skills.png) |

---

How it could look after updating the metadata after concatenating the documents:

<center>

![Meta Document Combined](/img/articles/resume/meta_resume.png)

</center>

## Local Development

If this isn't overkill enough then strap in. I primarily develop on Mac, so I use `pm2` and `fswatch` to rebuild pre-requisites when things are changed.

```bash
brew install fswatch
npm i -g pm2
```

The `ecosystem.config.js` will watch:

* `Dockerfile` to `make skills_docker`
  * i.e. rebuild docker container that is used to build skills tree
* `skills.tmpl`, `skills.sh` to `make skills_dot skills_png skills_svg skills_pdf`
  * i.e. the `dot` file used to build the skills tree
* `.env`, `src/` to `make build`
  * i.e. to make the CV and combines CV and skill into a single document

```js
// pm2 start ecosystem.config.js
// pm2 stop ecosystem.config.js
// pm2 status all

module.exports = {
  apps: [
    {
      name: "resume-docker",
      script: "fswatch --one-event --event=Updated Dockerfile && make skills_docker",
    },
    {
      name: "resume-skills",
      script: "fswatch --one-event --event=Updated skills.sh skills.tmpl && make skills_dot skills_png skills_svg skills_pdf",
    },
    {
      name: "resume-cv",
      script: "fswatch --one-event --event=Updated .env src/ && make build",
    }
  ]
};
```

<center>

![PM2 Dashboard](/img/articles/resume/pm2_monit.png)

</center>

## CI/CD

A workflow is configured to run when a `tag` is pushed.

I use this command below to see the most recent tags, and to see which will be the next logical release.

```bash
git --no-pager tag | grep -v "^v" | sort -V
```

Once I'm happy with the local build, I will `tag` and `push`:

```bash
git tag 1.2.0 -m 'good enough'
git push origin 1.2.0
```

---

<center>

![Github Workflow](/img/articles/resume/github_workflow.png)

</center>

The workflow will build all these assets, and included they are then included in a new release. Then a certain subset of these assets are uploaded to an `s3` bucket for use on my website and [github](https://github.com/alistaircol) profile.

<center>

![Github Release](/img/articles/resume/github_release.png)

</center>

Pretty cool (I think) ðŸ˜Ž.

Next step... dark mode CV...

## Samples

* one page: [Skills](/img/articles/resume/skills.pdf)
* one page: [CV](/img/articles/resume/cv.pdf)
* two pages: [CV & Skills](/img/articles/resume/resume.pdf)
